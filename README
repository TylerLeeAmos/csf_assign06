Tyler Amos, Justin Canedy:
tamos5@jhu.edu, jcanedy1@jhu.edu

To create the multiple calculator instances we used multithreading, wherein we created a new thread by using pthread and calling pthread_create() when a new calculator instance connected. We made sure the new thread was detatched by calling pthread_detach() so that upon closing it automatically deallocated all of its resources. Since all threads use the chat_with_client() function and Calc struct, which holds variables, the critical section of code where different calculator instances have shared data and where having concurrent accesses could cause problems lies within the vector in the Calc struct. To combat this we added pthread_mutex_lock to the struct fields in order to call when the Calc struct(its vector) is being accessed by a thread in the server. This causes all other server threads to enter a queue and wait until the current thread is finished accessing the shared data and releases the pthread_mutex_lock. Specifically, the place in which we called the lock was before an expression was being evaluated (as there's a chance the vector is accessed to store a variable). We unlocked afterwards. The lock is destroyed in the destructor.